use std::str::FromStr;
use crate::phases::frontend::lexer::Span;
use crate::phases::frontend::ast::*;

grammar(module_path: &str);

pub Module: ModuleAST = {
  <imports:ImportStatement*> <statements:TopLevelStatement*> => ModuleAST {
    path: module_path.to_string(),
    imports,
    statements,
  }
};

ImportStatement: Import = {
  <start: @L> "use" "@" <scope:Identifier> ":" <package:Identifier> <path:Path> <selectors:ImportSelectors> ";" <end: @R> => Import {
    span: Span { start, end },
    kind: ImportKind::Package {
      scope,
      package,
      path,
      selectors,
    }
  }
};

Path: Vec<Identifier> = {
  "/" <(<Identifier> "/")*>
};

ImportSelectors: Vec<ImportSelector> = {
  "{" <CommaList<ImportSelector>> "}"
};

ImportSelector: ImportSelector = {
  Identifier => ImportSelector {
    span: <>.span,
    kind: ImportSelectorKind::Name(<>.name),
  }
};

TopLevelStatement: TopLevelStatement = {
  #[precedence(level="0")]
  <start: @L> <variable_declaration:TopLevelVariableDeclaration> <end: @R> =>
    TopLevelStatement {
      span: Span { start, end },
      kind: variable_declaration,
    },

  #[precedence(level="1")]
  <start: @L> <expr:Expression> ";" <end: @R> => TopLevelStatement {
    span: Span { start, end },
    kind: TopLevelStatementKind::Expression(*expr),
  },
};

TopLevelVariableDeclaration: TopLevelStatementKind = {
  <is_public:"pub"?> <is_mutable:VariableBinding> <identifier:Identifier> "=" <initializer:Expression> ";" =>
    TopLevelStatementKind::VariableDeclaration {
      is_public: is_public.is_some(),
      is_mutable,
      type_: None, // TODO
      identifier,
      initializer,
    },
};

// true if mutable
// TODO: Better way of handling this
VariableBinding: bool = {
  "let" => false,
  "mut" => true,
}

Statement: Statement = {
  <start: @L> <expr:Expression> ";" <end: @R> => Statement {
    span: Span { start, end },
    kind: StatementKind::Expression(*expr),
  }
}

Expression: Box<Expression> = {
  AssignmentExpression,
};

AssignmentExpression: Box<Expression> = {
  LogicalOrExpression,

  <start: @L> <left:LeftHandSideExpression> <op:BinaryAssignmentOp> <right:AssignmentExpression> <end: @R> => Box::new(Expression::new(
    ExpressionKind::BinaryExpression(left, op, right),
    Span { start, end }
  )),
};

LogicalOrExpression: Box<Expression> = {
  LogicalAndExpression,

  <start: @L> <left:LogicalOrExpression> <op:BinaryOrOp> <right:LogicalAndExpression> <end: @R> =>
    Box::new(Expression::new(
      ExpressionKind::BinaryExpression(left, op, right),
      Span { start, end, }
    )),
};

LogicalAndExpression: Box<Expression> = {
  EqualityExpression,

  <start: @L> <left:LogicalAndExpression> <op:BinaryAndOp> <right:EqualityExpression> <end: @R> =>
    Box::new(Expression::new(
      ExpressionKind::BinaryExpression(left, op, right),
      Span { start, end, }
    )),
};

EqualityExpression: Box<Expression> = {
  RelationalExpression,

  <start: @L> <left:EqualityExpression> <op:BinaryEqualOp> <right:RelationalExpression> <end: @R> =>
    Box::new(Expression::new(
      ExpressionKind::BinaryExpression(left, op, right),
      Span { start, end, }
    )),

  <start: @L> <left:EqualityExpression> <op:BinaryNotEqualOp> <right:RelationalExpression> <end: @R> =>
    Box::new(Expression::new(
      ExpressionKind::BinaryExpression(left, op, right),
      Span { start, end, }
    )),
};

RelationalExpression: Box<Expression> = {
  AdditiveExpression,

  <start: @L> <left:RelationalExpression> <op:BinaryLessThanOrEqualOp> <right:AdditiveExpression> <end: @R> =>
    Box::new(Expression::new(
      ExpressionKind::BinaryExpression(left, op, right),
      Span { start, end, }
    )),

  <start: @L> <left:RelationalExpression> <op:BinaryGreaterThanOrEqualOp> <right:AdditiveExpression> <end: @R> =>
    Box::new(Expression::new(
      ExpressionKind::BinaryExpression(left, op, right),
      Span { start, end, }
    )),

  <start: @L> <left:RelationalExpression> <op:BinaryLessThanOp> <right:AdditiveExpression> <end: @R> =>
    Box::new(Expression::new(
      ExpressionKind::BinaryExpression(left, op, right),
      Span { start, end, }
    )),

  <start: @L> <left:RelationalExpression> <op:BinaryGreaterThanOp> <right:AdditiveExpression> <end: @R> =>
    Box::new(Expression::new(
      ExpressionKind::BinaryExpression(left, op, right),
      Span { start, end, }
    )),
};

AdditiveExpression: Box<Expression> = {
  MultiplicativeExpression,

  <start: @L> <left:AdditiveExpression> <op:BinaryAddOp> <right:MultiplicativeExpression> <end: @R> =>
    Box::new(Expression::new(
      ExpressionKind::BinaryExpression(left, op, right),
      Span { start, end, }
    )),

  <start: @L> <left:AdditiveExpression> <op:BinarySubOp> <right:MultiplicativeExpression> <end: @R> =>
    Box::new(Expression::new(
      ExpressionKind::BinaryExpression(left, op, right),
      Span { start, end, }
    )),
};

MultiplicativeExpression: Box<Expression> = {
  UnaryExpression,

  <start: @L> <left:MultiplicativeExpression> <op:BinaryMulOp> <right:UnaryExpression> <end: @R> =>
    Box::new(Expression::new(
      ExpressionKind::BinaryExpression(left, op, right),
      Span { start, end, }
    )),

  <start: @L> <left:MultiplicativeExpression> <op:BinaryDivOp> <right:UnaryExpression> <end: @R> =>
    Box::new(Expression::new(
      ExpressionKind::BinaryExpression(left, op, right),
      Span { start, end, }
    )),
};

UnaryExpression: Box<Expression> = {
  LeftHandSideExpression,

  <start: @L> "!" <expr:UnaryExpression> <end: @R> => Box::new(Expression::new(
    ExpressionKind::PreUnaryExpression(PreUnaryOperator::Not, expr),
    Span { start, end, }
  )),

  <start: @L> "++" <expr:UnaryExpression> <end: @R> => Box::new(Expression::new(
    ExpressionKind::PreUnaryExpression(PreUnaryOperator::Increment, expr),
    Span { start, end, }
  )),

  <start: @L> "--" <expr:UnaryExpression> <end: @R> => Box::new(Expression::new(
    ExpressionKind::PreUnaryExpression(PreUnaryOperator::Decrement, expr),
    Span { start, end, }
  )),
};

LeftHandSideExpression: Box<Expression> = {
  CallExpression,
};

CallExpression: Box<Expression> = {
  MemberExpression,

  <start: @L> <callee:CallExpression> <arguments:Arguments> <end: @R> => Box::new(Expression::new(
    ExpressionKind::FunctionCall { callee, arguments, },
    Span { start, end, }
  )),

  <start: @L> <left:CallExpression> "." <right:Identifier> <end: @R> => Box::new(Expression::new(
    ExpressionKind::PropertyAccess(left, right),
    Span { start, end, }
  )),
};

MemberExpression: Box<Expression> = {
  IfExpression,
};

IfExpression: Box<Expression> = {
  #[precedence(level="0")]
  <start: @L> "if" <condition:Expression> <body:Block> <else_:("else" <Block>)?> <end: @R> => {
    let body_span = body.span.clone();

    Box::new(Expression::new(
      ExpressionKind::If {
        condition,
        body: Box::new(Expression::new(
          ExpressionKind::Block(Box::new(body)),
          body_span,
        )),
        else_: else_.map(|else_| {
          let span = else_.span.clone();
          Box::new(Expression::new(
            ExpressionKind::Block(Box::new(else_)),
            span,
          ))
        }),
      },
      Span { start, end, },
    ))
  },

  #[precedence(level="1")]
  Term,
};

Term: Box<Expression> = {
  <start: @L> <value:Boolean> <end: @R> =>
    Box::new(Expression::new(ExpressionKind::Boolean(value), Span { start, end })),

  <start: @L> <value:Integer> <end: @R> =>
    Box::new(Expression::new(ExpressionKind::Integer(value), Span { start, end })),

  <start: @L> <value:String> <end: @R> =>
    Box::new(Expression::new(ExpressionKind::String(value), Span { start, end })),

  <start: @L> <value:Block> <end: @R> =>
    Box::new(Expression::new(ExpressionKind::Block(Box::new(value)), Span { start, end })),

  <start: @L> <value:Identifier> <end: @R> =>
    Box::new(Expression::new(ExpressionKind::Identifier(value), Span { start, end })),

  "(" <Expression> ")",
};

Arguments: Vec<Expression> = {
  "(" <CommaList<Expression>> ")" => <>.into_iter().map(|expr| *expr).collect(),
};

Boolean: bool = {
  "true" => true,
  "false" => false,
};

Identifier: Identifier = {
  <start: @L> <name:r"[a-zA-Z_][a-zA-Z_0-9]*(-+[a-zA-Z_0-9]+)*"> <end: @R> => {
    Identifier {
      name: name.to_string(),
      span: Span { start, end },
    }
  }
};

Integer: i32 = {
  r"0|[1-9][0-9]*(_[0-9]+)*" => i32::from_str(&str::replace(<>, "_", "")).unwrap(),
};

String: String = {
  r#""(\\[rnt\"]|[^\"])*""# => <>[1..(<>.len() - 1)].to_string(),
  r#"'(\\[rnt\']|[^\'])*'"# => <>[1..(<>.len() - 1)].to_string(),
};

Block: Block = {
  <start: @L> "{" <statements:Statement*> <return_expression:Expression?> "}" <end: @R> => Block {
    span: Span { start, end },
    statements,
    return_expression: return_expression.map(|expr| *expr),
  }
}

FactorOp = {
  BinaryMulOp,
  BinaryDivOp,
};

TermOp = {
  BinaryAddOp,
  BinarySubOp,
};

// TODO: Rename. Implies they operate on bits
BinaryAddOp: BinaryOperator                = "+"  => BinaryOperator::Add;
BinarySubOp: BinaryOperator                = "-"  => BinaryOperator::Sub;
BinaryMulOp: BinaryOperator                = "*"  => BinaryOperator::Mul;
BinaryDivOp: BinaryOperator                = "/"  => BinaryOperator::Div;
BinaryModulusOp: BinaryOperator            = "%"  => BinaryOperator::Modulus;
BinaryNotEqualOp: BinaryOperator           = "!=" => BinaryOperator::NotEqual;
BinaryEqualOp: BinaryOperator              = "==" => BinaryOperator::Equal;
BinaryLessThanOp: BinaryOperator           = "<"  => BinaryOperator::LessThan;
BinaryLessThanOrEqualOp: BinaryOperator    = "<=" => BinaryOperator::LessThanOrEqual;
BinaryGreaterThanOp: BinaryOperator        = ">"  => BinaryOperator::GreaterThan;
BinaryGreaterThanOrEqualOp: BinaryOperator = ">=" => BinaryOperator::GreaterThanOrEqual;
BinaryAndOp: BinaryOperator                = "&&" => BinaryOperator::And;
BinaryOrOp: BinaryOperator                 = "||" => BinaryOperator::Or;
BinaryAssignmentOp: BinaryOperator         = "="  => BinaryOperator::Assignment;

CommaList<T>: Vec<T> = {
  <mut items:(<T> ",")*> <end:T?> => match end {
    None => items,
    Some(end) => {
      items.push(end);
      items
    }
  }
};

// Skip whitespace and comments
match {
  r"\s*" => { },
  r"//[^\r\n]*[\r\n]*" => { },
  r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },
  _
}